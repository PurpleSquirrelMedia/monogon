// Copyright 2020 The Monogon Project Authors.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package api;

option go_package = "git.monogon.dev/source/nexantic.git/core/generated/api";

// TODO(leo): A "cluster" in terms of this API is an etcd cluster. We have
// since realized that we will need multiple kinds of nodes in a Smalltown cluster
// (like worker nodes), which aren't etcd members. This API is pretty strongly
// coupled to etcd at this point. How do we handle cluster membership for
// workers?

// The ClusterManagement service is used by an authenticated administrative user
// to manage node membership in an existing Smalltown cluster.
service ClusterManagement {
  // Add a node to the cluster, subject to successful remote attestation.
  rpc AddNode(AddNodeRequest) returns (AddNodeResponse) {}

  // Remove a node from the cluster.
  rpc RemoveNode(RemoveNodeRequest) returns (RemoveNodeRequest) {}

  // List all cluster nodes
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse) {}

  // NewEnrolmentConfig generates a new enrolment config for adding new nodes to
  // the cluster
  rpc NewEnrolmentConfig(NewEnrolmentConfigRequest)
      returns (NewEnrolmentConfigResponse) {}

  rpc ListEnrolmentConfigs(ListEnrolmentConfigsRequest)
      returns (ListEnrolmentConfigsResponse) {}

  rpc RemoveEnrolmentConfig(RemoveEnrolmentConfigRequest)
      returns (RemoveEnrolmentConfigResponse) {}
}

message NewEnrolmentConfigRequest { string name = 1; }
message NewEnrolmentConfigResponse { EnrolmentConfig enrolment_config = 1; }

message ListEnrolmentConfigsRequest {}
message ListEnrolmentConfigsResponse {
  repeated EnrolmentConfig enrolment_config = 1;
}

message RemoveEnrolmentConfigRequest {
  // TODO(lorenz): How do we want to remove EnrolmentConfigs?
}
message RemoveEnrolmentConfigResponse {}

// NodeService runs on all nodes and allows active masters to perform things
// like attestation or grab other system state. Callers are authenticated via
// TLS using the certificate from the EnrolmentConfig. Any client needs to
// authenticate the node it's talking to by getting the public key from the
// consensus service to verify against.
service NodeService {
  rpc JoinCluster(JoinClusterRequest) returns (JoinClusterResponse) {}
}

// NodeManagementService runs on all masters, is identified by the
// NodeManagementService TLS certificate and is where nodes report to when they
// initially join or are restarted and need to be unlocked again.
service NodeManagementService {
  // NewTPM2NodeRegister is called by a node as soon as it is properly
  // initialized. Then any number of policies can determine weather and when to
  // add the node to the cluster.
  //
  // The idea behind this is that we just deliver everything we have trust-wise
  // and then it's up to the customer or his policies to either adopt this node
  // or not since TPM trust hierarchies are a mess in general.
  rpc NewTPM2NodeRegister(stream TPM2FlowRequest)
      returns (stream TPM2FlowResponse) {}

  // Nodes that were rebooted request their global unlock secret from here.
  rpc TPM2Unlock(stream TPM2UnlockFlowRequeset)
      returns (stream TPM2UnlockFlowResponse) {}
}

/*
This flow needs to run in a single TLS session, so we force that with
bidirectional streaming. It works like this New Node NodeManagementService
TPM2RegisterRequest ------>
                   <------  TPM2AttestRequest
TPM2AttestResponse  ------>
NewNodeInfo         ------>
*/

message TPM2FlowRequest {
  oneof Stage {
    TPM2RegisterRequest register = 1;
    TPM2AttestResponse attest_response = 2;
    NewNodeInfo new_node_info = 3;
  }
}

message TPM2FlowResponse {
  oneof Stage { TPM2AttestRequest attest_request = 1; }
}

// EnrolmentConfig is attached to an installation payload
message EnrolmentConfig {
  bytes enrolment_secret = 1;
  bytes masters_cert = 2; // X.509 DER certificate of the NodeManagement service
  repeated bytes master_ips = 3; // IPs where the NodeManagement service runs
  // Filled in by node after it is enrolled
  string node_id = 4;
}

message TPM2RegisterRequest {
  bytes ak_public = 9; // AK public portion, TPM2_PUBLIC
  bytes ek_pubkey = 5; // TPM EK public key, PKIX
  bytes ek_cert = 6; // TPM EK certificate, X.509 DER (only if available in TPM)
}

message TPM2AttestRequest {
  bytes ak_challenge = 1;
  bytes ak_challenge_secret = 2;
  bytes quote_nonce = 3;
}

message TPM2AttestResponse {
  bytes quote = 1;
  bytes quote_signature = 4;

  bytes ak_challenge_solution = 2;
  repeated bytes pcrs = 3; // All 16 SHA256 SRTM PCRs in order
}

message NewNodeInfo {
  EnrolmentConfig enrolment_config = 1;

  bytes ip = 11; // IP of the node

  bytes id_cert = 4; // ID certificate, X.509 DER

  // Part of the encryption key for cluster unlock (32 byte), to be XOR'ed with
  // the node-local part on the TPM
  bytes global_unlock_key = 7;
}

message TPM2UnlockInit { bytes nonce = 1; }

message TPM2UnlockRequest {
  string node_id = 4;
  repeated bytes pcrs = 1;
  bytes quote = 2;
  bytes quote_signature = 3;
}

message TPM2UnlockResponse { bytes global_unlock_key = 1; }

message TPM2UnlockFlowRequeset {
  oneof Stage { TPM2UnlockRequest unlock_request = 1; }
}

message TPM2UnlockFlowResponse {
  oneof Stage {
    TPM2UnlockInit unlock_init = 1;
    TPM2UnlockResponse unlock_response = 2;
  }
}

// ConsensusCertificates is a node's individual etcd certificates.
// When provisioning a new node, the existing node sends the new node
// its certificates after authenticating it.
message ConsensusCertificates {
  bytes ca = 1;
  bytes crl = 2;
  bytes cert = 3;
  bytes key = 4;
}

message JoinClusterRequest {
  // Cluster bootstrap URI for etcd. The caller will set this to the
  // list of existing nodes in the cluster. This value is only used during
  // bootstrap.
  string initialCluster = 2;
  // New node's etcd client certificates
  ConsensusCertificates certs = 3;
}

message JoinClusterResponse {}

message AddNodeRequest {
  string node_id = 1;
  // TODO: Add things like role
}

message AddNodeResponse {}

message RemoveNodeRequest {}

message RemoveNodeResponse {}

message ListNodesRequest {}

message ListNodesResponse { repeated Node nodes = 1; }

message NodeTPM2 {
  bytes ak_pub = 1;    // TPM2T_PUBLIC
  bytes ek_pubkey = 2; // PKIX DER
  bytes ek_cert = 3;   // X.509 DER
}

// Node describes a single node's state
message Node {
  bytes id_cert = 5;
  bytes global_unlock_key = 7;
  bytes address = 3;
  enum State {
    UNININITALIZED = 0; // WARNING: In this state the node has not been adopted and thus cannot be fully trusted
    MASTER = 1; // A full master node with Consensus, NMS & Kubernetes control plane
    WORKER = 2; // A worker node with just Kubelet and supporting services
  }
  State state = 9;

  oneof integrity { NodeTPM2 tpm2 = 6; }

  // etcd State (might later be moved to a separate type)

  // etcd member ID
  uint64 id = 1;
  // etcd member name
  string name = 2;
  // Whether the etcd member is synced with the cluster.
  bool synced = 4;
}